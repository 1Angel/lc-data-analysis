#!/usr/bin/env python

'''
Check lesson files and their contents.
'''

import sys
import os
import glob
import json
import yaml
import re
from subprocess import Popen, PIPE
from optparse import OptionParser

from util import Reporter


# Where to look for source Markdown files.
SOURCE_DIRS = ['', '_episodes', '_extras']

# Required files (YAML_required, path).
# The '%' is replaced with the source directory path for checking.
# Episodes are handled specially, and extra files in '_extras' are also handled specially.
# This list must include all the Markdown files listed in the 'bin/initialize' script.
REQUIRED_FILES = [
    (True, '%/CONDUCT.md'),
    (False, '%/CONTRIBUTING.md'),
    (True, '%/LICENSE.md'),
    (False, '%/README.md'),
    (True, '%/_extras/discuss.md'),
    (True, '%/_extras/guide.md'),
    (True, '%/index.md'),
    (True, '%/reference.md'),
    (True, '%/setup.md')
]

# Episode filename pattern.
P_EPISODE_FILENAME = re.compile(r'/_episodes/(\d\d)-[-\w]+.md$')


def main():
    '''Main driver.'''

    args = parse_args()
    args.reporter = Reporter(args)
    docs = read_all_markdown(args, args.source_dir)
    check_fileset(args, docs)
    for filename in docs.keys():
        checker = create_checker(args, filename, docs[filename][0], docs[filename][1])
        checker.check()
    args.reporter.report()


def parse_args():
    '''Parse command-line arguments.'''

    parser = OptionParser()
    parser.add_option('-p', '--parser',
                      default=None,
                      dest='parser',
                      help='path to Markdown parser')
    parser.add_option('-s', '--source',
                      default=os.curdir,
                      dest='source_dir',
                      help='source directory')

    args, extras = parser.parse_args()
    require(args.parser is not None,
            'Path to Markdown parser not provided')
    require(not extras,
            'Unexpected trailing command-line arguments "{0}"'.format(extras))

    return args


def read_all_markdown(args, source_dir):
    '''Read source files, returning {path : (yaml, parsetree)}.'''

    all_dirs = [os.path.join(source_dir, d) for d in SOURCE_DIRS]
    all_patterns = [os.path.join(d, '*.md') for d in all_dirs]
    result = {}
    for pat in all_patterns:
        for filename in glob.glob(pat):
            data = read_markdown(args, filename)
            if data:
                result[filename] = data
    return result


def read_markdown(args, path):
    '''Get YAML and AST for Markdown file, returning pair (yaml | None, json).'''

    # Initialize.
    header = None
    with open(path, 'r') as reader:
        body = reader.read()

    # Split and extract YAML (if present).
    pieces = body.split('---', 2)
    if len(pieces) == 3:
        header = yaml.load(pieces[1])
        body = pieces[2]

    # Parse Markdown.
    cmd = 'ruby {0}'.format(args.parser)
    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, close_fds=True, universal_newlines=True)
    stdout_data, stderr_data = p.communicate(body)
    doc = json.loads(stdout_data)

    return (header, doc)


def check_fileset(args, docs):
    '''Are all required files present? Are extraneous files present?'''

    # Check files with predictable names.
    actual = docs.keys()
    required = [p[1].replace('%', args.source_dir) for p in REQUIRED_FILES]
    missing = set(required) - set(actual)
    for m in missing:
        args.reporter.add('Missing required file {0}'.format(m))

    # Check episode files' names.
    seen = []
    for filename in actual:
        if '_episodes' not in filename:
            continue
        m = P_EPISODE_FILENAME.search(filename)
        if m and m.group(1):
            seen.append(m.group(1))
        else:
            args.reporter.add('Episode {0} has badly-formatted filename'.format(e))

    # Check episode filename numbering.
    args.reporter.check(len(seen) == len(set(seen)),
                        'Duplicate episode numbers {0} vs {1}'.format(sorted(seen), sorted(set(seen))))
    seen = [int(s) for s in seen]
    seen.sort()
    args.reporter.check(all([i+1 == n for (i, n) in enumerate(seen)]),
                        'Missing or non-consecutive episode numbers {0}'.format(seen))


def create_checker(args, filename, metadata, doc):
    '''Create appropriate checker for file.'''

    for (pat, cls) in CHECKERS:
        if pat.match(filename):
            return cls(args, filename, metadata, doc)


def require(condition, message):
    '''Fail if condition not met.'''

    if not condition:
        print(message, file=sys.stderr)
        sys.exit(1)


class ValidateGeneric(object):
    '''Generic Markdown file checker.'''

    def __init__(self, args, filename, metadata, doc):
        '''Cache arguments for checking.'''

        super(ValidateGeneric, self).__init__()
        self.args = args
        self.filename = filename
        self.metadata = metadata
        self.doc = doc

    def check(self):
        '''Run tests on metadata.'''

        self.check_metadata()
        self.check_body()

    def check_metadata(self):
        '''Check the YAML metadata.'''

        if self.metadata is None:
            return

        pass # FIXME

    def check_body(self):
        '''Run generic tests on body of document.'''

        for node in self.findall(self.doc, 'blockquote'):
            print(node)


    def findall(self, node, node_type, accum=None):
        '''Find matches.'''

        if accum is None:
            accum = []
        if node.get('type', None) == node_type:
            accum.append(node)
        for child in node.get('children', []):
            self.findall(child, node_type, accum)
        return accum


CHECKERS = [
    (re.compile(r''), ValidateGeneric)
]


if __name__ == '__main__':
    main()
