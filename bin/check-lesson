#!/usr/bin/env python

'''
Validate lesson files and their contents.
'''

import sys
import os
import glob
import json
import yaml
from subprocess import Popen, PIPE
from optparse import OptionParser


# Where to look for source Markdown files.
SOURCE_DIRS = ['', '_episodes', '_extras']

# Required files (YAML_required, path).
# The '%' is replaced with the source directory path for checking.
# Episodes are handled specially, and extra files in '_extras' are also handled specially.
# This list must include all the Markdown files listed in the 'bin/initialize' script.
REQUIRED_FILES = [
    (True, '%/CONDUCT.md'),
    (False, '%/CONTRIBUTING.md'),
    (True, '%/LICENSE.md'),
    (False, '%/README.md'),
    (True, '%/_extras/discuss.md'),
    (True, '%/_extras/guide.md'),
    (True, '%/index.md'),
    (True, '%/reference.md'),
    (True, '%/setup.md')
]


class Reporter(object):
    '''Collect and report errors.'''

    def __init__(self, args):
        '''Constructor.'''

        super(Reporter, self).__init__()
        self.messages = []

    def check(self, condition, message):
        '''Append error if condition not met.'''

        if not condition:
            self.add(message)


    def add(self, message):
        '''Append error unilaterally.'''

        self.messages.append(message)


    def report(self, stream=sys.stdout):
        '''Report all messages.'''

        for m in self.messages:
            print(m, file=stream)


def main():
    '''Main driver.'''

    args = parse_args()
    args.reporter = Reporter(args)
    docs = read_all_markdown(args, args.source_dir)
    check_fileset(args, docs)
    for filename in docs.keys():
        val = create_validator(args, filename)
        val.check(args, filename)
    reporter.report()


def parse_args():
    '''Parse command-line arguments.'''

    parser = OptionParser()
    parser.add_option('-p', '--parser',
                      default=None,
                      dest='parser',
                      help='path to Markdown parser')
    parser.add_option('-s', '--source',
                      default=os.curdir,
                      dest='source_dir',
                      help='source directory')

    args, extras = parser.parse_args()
    require(args.parser is not None,
            'Path to Markdown parser not provided')
    require(not extras,
            'Unexpected trailing command-line arguments "{0}"'.format(extras))

    return args


def read_all_markdown(args, source_dir):
    '''Read source files, returning {path : (yaml, parsetree)}.'''

    all_dirs = [os.path.join(source_dir, d) for d in SOURCE_DIRS]
    all_patterns = [os.path.join(d, '*.md') for d in all_dirs]
    result = {}
    for pat in all_patterns:
        for filename in glob.glob(pat):
            data = read_markdown(args, filename)
            if data:
                result[filename] = data
    return result


def read_markdown(args, path):
    '''Get YAML and AST for Markdown file, returning pair (yaml | None, json).'''

    # Initialize.
    header = None
    with open(path, 'r') as reader:
        body = reader.read()

    # Split and extract YAML (if present).
    pieces = body.split('---', 2)
    if len(pieces) == 3:
        header = yaml.load(pieces[1])
        body = pieces[2]

    # Parse Markdown.
    cmd = 'ruby {0}'.format(args.parser)
    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, close_fds=True, universal_newlines=True)
    stdout_data, stderr_data = p.communicate(body)
    doc = json.loads(stdout_data)

    return (header, doc)


def check_fileset(args, docs):
    '''Are all required files present? Are extraneous files present?'''

    actual = docs.keys()
    required = [p[1].replace('%', args.source_dir) for p in REQUIRED_FILES]
    missing = set(required) - set(actual)
    for m in missing:
        args.reporter.add('Missing required file {0}'.format(m))


def create_validator(args, filename):
    '''Create appropriate validator for file.'''

    return None # FIXME


def require(condition, message):
    '''Fail if condition not met.'''

    if not condition:
        print(message, file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
