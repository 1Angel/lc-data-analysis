#!/usr/bin/env python

'''
Validate lesson files and their contents.
'''

import sys
import os
import glob
import json
import yaml
import re
from subprocess import Popen, PIPE
from optparse import OptionParser

from util import Reporter


# Where to look for source Markdown files.
SOURCE_DIRS = ['', '_episodes', '_extras']

# Required files (YAML_required, path).
# The '%' is replaced with the source directory path for checking.
# Episodes are handled specially, and extra files in '_extras' are also handled specially.
# This list must include all the Markdown files listed in the 'bin/initialize' script.
REQUIRED_FILES = [
    (True, '%/CONDUCT.md'),
    (False, '%/CONTRIBUTING.md'),
    (True, '%/LICENSE.md'),
    (False, '%/README.md'),
    (True, '%/_extras/discuss.md'),
    (True, '%/_extras/guide.md'),
    (True, '%/index.md'),
    (True, '%/reference.md'),
    (True, '%/setup.md')
]

# Episode filename pattern.
P_EPISODE_FILENAME = re.compile(r'/_episodes/(\d\d)-[-\w]+.md$')


def main():
    '''Main driver.'''

    args = parse_args()
    args.reporter = Reporter(args)
    docs = read_all_markdown(args, args.source_dir)
    check_fileset(args, docs)
    for filename in docs.keys():
        val = create_validator(args, filename)
        val.check(args, filename)
    args.reporter.report()


def parse_args():
    '''Parse command-line arguments.'''

    parser = OptionParser()
    parser.add_option('-p', '--parser',
                      default=None,
                      dest='parser',
                      help='path to Markdown parser')
    parser.add_option('-s', '--source',
                      default=os.curdir,
                      dest='source_dir',
                      help='source directory')

    args, extras = parser.parse_args()
    require(args.parser is not None,
            'Path to Markdown parser not provided')
    require(not extras,
            'Unexpected trailing command-line arguments "{0}"'.format(extras))

    return args


def read_all_markdown(args, source_dir):
    '''Read source files, returning {path : (yaml, parsetree)}.'''

    all_dirs = [os.path.join(source_dir, d) for d in SOURCE_DIRS]
    all_patterns = [os.path.join(d, '*.md') for d in all_dirs]
    result = {}
    for pat in all_patterns:
        for filename in glob.glob(pat):
            data = read_markdown(args, filename)
            if data:
                result[filename] = data
    return result


def read_markdown(args, path):
    '''Get YAML and AST for Markdown file, returning pair (yaml | None, json).'''

    # Initialize.
    header = None
    with open(path, 'r') as reader:
        body = reader.read()

    # Split and extract YAML (if present).
    pieces = body.split('---', 2)
    if len(pieces) == 3:
        header = yaml.load(pieces[1])
        body = pieces[2]

    # Parse Markdown.
    cmd = 'ruby {0}'.format(args.parser)
    p = Popen(cmd, shell=True, stdin=PIPE, stdout=PIPE, close_fds=True, universal_newlines=True)
    stdout_data, stderr_data = p.communicate(body)
    doc = json.loads(stdout_data)

    return (header, doc)


def check_fileset(args, docs):
    '''Are all required files present? Are extraneous files present?'''

    # Check files with predictable names.
    actual = docs.keys()
    required = [p[1].replace('%', args.source_dir) for p in REQUIRED_FILES]
    missing = set(required) - set(actual)
    for m in missing:
        args.reporter.add('Missing required file {0}'.format(m))

    # Check episode files' names.
    seen = []
    for filename in actual:
        if '_episodes' not in filename:
            continue
        m = P_EPISODE_FILENAME.search(filename)
        if m and m.group(1):
            seen.append(m.group(1))
        else:
            args.reporter.add('Episode {0} has badly-formatted filename'.format(e))

    # Check episode filename numbering.
    args.reporter.check(len(seen) == len(set(seen)),
                        'Duplicate episode numbers {0} vs {1}'.format(sorted(seen), sorted(set(seen))))
    seen = [int(s) for s in seen]
    seen.sort()
    args.reporter.check(all([i+1 == n for (i, n) in enumerate(seen)]),
                        'Missing or non-consecutive episode numbers {0}'.format(seen))


def create_validator(args, filename):
    '''Create appropriate validator for file.'''

    return None # FIXME


def require(condition, message):
    '''Fail if condition not met.'''

    if not condition:
        print(message, file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()
